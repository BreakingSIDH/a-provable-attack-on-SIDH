load('generate_public_values.sage')
load('attack_aux.sage')
load('richelot_aux.sage')
load('speedup.sage')
import time
time_setup = time.time()

la, lb = 3, 2
ea, eb = 9, 19
A, B = la^ea, lb^eb
p = A*B - 1
Fp2.<i> = GF(p^2, modulus=[1,0,1])

E0 = EllipticCurve(Fp2, [0,6,0,1,0])
E0.set_order((p+1)^2, num_checks=0)


#----------------------------------------------------------------------
# Step 0: Create a challenge with toy parameters and mask the
#         endomorphism ring of the starting curve.
#----------------------------------------------------------------------
# Starting from a random curve
rndcrv  = randint(0,200)
for _ in range(rndcrv):
    xs = E0.two_division_polynomial().roots(multiplicities=False)
    E0 = E0.isogeny(E0.lift_x(choice(xs))).codomain()

# Generating public torsion points
PA, QA, PB, QB = generate_torsion_points(E0, la, ea, lb, eb)
assert check_torsion_points(E0, la, ea, lb, eb, PA, QA, PB, QB)

print("----------------------------------------------------------------------")
print("The starting curve is")
print(E0)
print("----------------------------------------------------------------------")
print(f"The 3^{ea}-torsion group is generated by")
print(PA)
print(QA)
print("----------------------------------------------------------------------")
print(f"The 2^{eb}-torsion group is generated by")
print(PB)
print(QB)
print("----------------------------------------------------------------------")

# Generate Alice's key pair
alice_private, (EA, phiPB, phiQB) = gen_keypair(E0, PA, QA, PB, QB, la, ea)

print("The public key is")
print(EA)
print(phiPB)
print(phiQB)
print("----------------------------------------------------------------------")
print(f"If successful, the attack will recover the secret: {alice_private}")
print("----------------------------------------------------------------------")
print("Generating the public parameters for the attack required {:.2f}s".format(time.time() - time_setup))
print("----------------------------------------------------------------------")


# Toy parameter set
#----------------------------------------------------------------------
# Step 1: Compute integers such that eB' = f + A'.
#         This has been precomputed for this toy example.
#----------------------------------------------------------------------
the_i = 1
the_e = 2
the_j = 0
the_f = 5 * 13 * 17 * 23 * 41

A_prime = A // (la^the_i)
B_prime = B // (lb^the_j)
# We compute a chain of length
# eB'. We assume e is a power 
# of two
chain_length = log(the_e*B_prime, 2)

assert the_e * B_prime == the_f + A_prime
the_c = inverse_mod(A_prime, the_e * B_prime)

# factors_f = ecm.factor(the_f)
# Precompute factors:
factors_f = [5,13,17,23,41]
E_temp = E0
PB_temp = PB
QB_temp = QB

#----------------------------------------------------------------------
# Step 2: Compute a curve f-isogenous to E0.
#         Here, we compute a chain of isogenies for each factor of
#         f, the degree of the cofactor isogeny.
#
#         Each isogeny in the chain is computed by finding the minimal
#         extension E / Fp^k such that there is a point of order q.
#         This point is used to generate a kernel polynomial from which
#         we obtain an isogeny to a new curve in E/Fp2.
#----------------------------------------------------------------------
tin = time.time()
for q in factors_f:
    P = gen_point_order_q(E_temp, q)
    kerpoly = kerpoly_from_point(P)
    phi_temp = E_temp.isogeny(kerpoly)
    PB_temp = phi_temp(E_temp(PB_temp))
    QB_temp = phi_temp(E_temp(QB_temp))
    E_temp = phi_temp.codomain()
tfin = time.time()
print("Computing the dual of the cofactor isogeny required %0.2fs" % (tfin - tin))
print("----------------------------------------------------------------------")

# E is the domain of the f-isogeny varphi_f : E -> E0
# PB_E denotes \hat{varphi}_f(PB)
# Similarly for QB_E 
E = E_temp
PB_E = PB_temp 
QB_E = QB_temp

#----------------------------------------------------------------------
# Step 3: Compute a basis P_{eB'}, Q_{eB'} of E[eB']
#         To do this, we find the minimal extension degree `deg`,
#         following this, we compute the basis. Note that as j=0
#         for our parameters, we skip the multiplication by \ell^j
#----------------------------------------------------------------------
# extending the base field to find points dividing PB_E and QB_E
deg = min(i for i,n in enumerate(E.count_points(the_e+1),1) if (the_e*B_prime).divides(sqrt(n)))
Fq.<T> = Fp2.extension(deg)
E_ext = E.base_extend(Fq)

P_eBprime = divide_by(E_ext(PB_E), the_e)
Q_eBprime = divide_by(E_ext(QB_E), the_e)

# Short hand for Weil pairing of fixed degree eB'
pair = lambda P,Q: P.weil_pairing(Q, the_e*B_prime)


#----------------------------------------------------------------------
# Step 4: Make a guess \phi_{\ell_A^i}.
#         This requires first guessing the isogeny, computing the basis
#         R,S. As this requires dividing by e, there is a list of all
#         possible values, so the higher e, the more guesses that will
#         need to be made for each isogeny guess.
#
# Step 5: Test the guess \phi_{\ell_A^i}.
#         In our code, we combin steps 4,5. Once we have our guess
#         \phi_{\ell_A^i} with the basis R,S of E'[eB'] then we test
#         the correctness of the guess with the oracle `Does22ChainSplit`.
#         This computes an (eB', eB')-isogeny with domain E x E'. If the
#         codomain of this isogeny splits as a product of elliptic curves
#         the guess is correct. 
#----------------------------------------------------------------------
def guess_last_steps_dual(Et,i):
    P,Q = (R.element() for R in Et.abelian_group().torsion_subgroup(la^i).gens())
    vs = [(1,y) for y in range(la^i)] + [(x,1) for x in range(0,la^i,la)]
    for v in vs:
        yield Et.isogeny(v[0]*P + v[1]*Q, algorithm='factored')

def guess_isogeny():  
    inv_la_the_i = inverse_mod(la^the_i, B_prime)
    pair_P_eBprime_Q_eBprime = pair(P_eBprime, Q_eBprime)
    for isogenia in guess_last_steps_dual(EA,the_i):
        print(f"Guessing the last i={the_i} step(s)")
        E_prime = isogenia.codomain()
        dual_phi_ellA_i_phiPB = isogenia(phiPB)
        dual_phi_ellA_i_phiQB = isogenia(phiQB)
        E_prime_ext = E_prime.base_extend(Fq)
        dual_phi_ellA_i_phiPB = E_prime_ext(dual_phi_ellA_i_phiPB)
        dual_phi_ellA_i_phiQB = E_prime_ext(dual_phi_ellA_i_phiQB)
        list_R = divide_by((inv_la_the_i*the_f)*dual_phi_ellA_i_phiPB, the_e, all=True)
        list_S = divide_by((inv_la_the_i*the_f)*dual_phi_ellA_i_phiQB, the_e, all=True) 
        print(f"Trying options for eBlb^(-j)-torsion points")
        filter_points = []        
        for R in list_R:
            for S in list_S:
                if pair_P_eBprime_Q_eBprime * pair(R, S)^(the_c^2) == 1:
                        filter_points.append((R,S))
        print(f"Need to check: {len(filter_points)} pairs of points")
        for i, (R,S) in enumerate(filter_points):
            print(f"Guess {i}", end="")
            chain, codomain = Does22ChainSplit(E_ext, E_prime_ext, P_eBprime, Q_eBprime, the_c*R, the_c*S, chain_length)
            if codomain is not None:
                print(f"\r", end="")
                print("----------------------------------------------------------------------")
                return chain, codomain, isogenia, R, S
            print(f"\r", end="")
        print("----------------------------------------------------------------------")
    print(f"Something is broken... Exiting...")
    exit()

t_guess = time.time()
chain, codomain, isogenia, R, S = guess_isogeny()
print("Guessing the correct isogeny required %0.2fs" % (time.time() - t_guess))

#----------------------------------------------------------------------
# Step 6: Compute the basis P,Q of E'[A'] and the image of these points
#         \hat{\phi}'(P), \hat{\phi}'(Q).
#         
#         This is accomplished by mapping points through the previously
#         computed (eB', eB')-isogeny chain. 
#----------------------------------------------------------------------
# Checking if the isomorphism swapped the curves in the codomain
if codomain[0].j_invariant() == E0.j_invariant():
    index = 0
else:
    index = 1
    
E0t = codomain[index]

# computing the dual of the first a-i steps
E_prime = isogenia.codomain()
E_prime_ext = E_prime.base_extend(Fq)
PAA, QAA = ( ((p+1) // (la^ea))*G for G in EA.gens())
PAA_E_prime = isogenia(PAA)
QAA_E_prime = isogenia(QAA)
PAA_E_prime = E_prime_ext(PAA_E_prime)
QAA_E_prime = E_prime_ext(QAA_E_prime)

# Map the points using the computed isogeny chain
imPAA = (E_ext(0), PAA_E_prime)
imQAA = (E_ext(0), QAA_E_prime)
for f in chain:
    imPAA = f(imPAA)
    imQAA = f(imQAA)


print("----------------------------------------------------------------------")
E0_ext = E0.change_ring(Fq)
# we have computed the dual up to isomorphisms 
psi_list = E0t.isomorphisms(E0_ext)

#----------------------------------------------------------------------
# Step 7: Compute the kernel of \phi'. From this and the correct guess
#         of \phi_{\ell_A^i}, we recover the kernel of Alice's secret
#         isogeny. 
#         
#         The secret key `x`, from K_A = P + xQ can be recovered by
#         using Weil pairings and solving the discrete logarithm
#         which is efficent as the degree of the isogeny is smooth. 
#----------------------------------------------------------------------
#finding the kernel generator of the first a-i steps
if (3^(ea-1))*imPAA[index] != imPAA[index].curve()(0):
    K = imPAA[index]
else:
    K = imQAA[index]
    
for psi in psi_list:
    K = E0(psi(K))
    recovered_isogeny = E0.isogeny(K, algorithm="factored")
    recovered_curve = recovered_isogeny.codomain()
    if recovered_curve == EA:
        recovered_key = find_secret_key_pairing(K, PA, QA, ea)
        print(f"Secret key recovered: {recovered_key}")
        print(f"The attack is successful: {recovered_key == alice_private}")
        break
print("----------------------------------------------------------------------")
print("Altogether, the attack required {:.2f}s".format(time.time() - tin))
